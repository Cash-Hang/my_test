*************** Golang中优秀的消息队列NSQ基础安装及使用 ******************
//https://blog.csdn.net/sd653159/article/details/83624661


1 ： 背景介绍

2 ： nsq 服务介绍

    （1）nsqlookupd : 主要负责服务发现，负责nsqd的心跳,状态监测 。给客户端,nsqadmin提供nsqd地址与状态
    ====启动命令：nsqlookupd

    （2）nsqd : 负责接收消息，存储队列和将消息发送给客户端。nsqd可以多机器部署，当你使用客户端像一个topic发送消息的时候，
    可以分配多个nsqd地址，消息会随机的分配到各个nsqd上，nsqd优先把消息存储到内存channel中，当内存channel满了之后，
    则把消息写入磁盘文件。nsqd监听了2个tcp端口，一个用来服务客户端，一个用来提供http的接口
    ====启动命令：nsqd --lookupd-tcp-address=127.0.0.1:4160
    
    （3）nsqadmin : 是一个web管理页面
    ====启动命令：nsqadmin --lookupd-http-address=127.0.0.1:4161
    启动之后，可以通过http://127.0.0.1:4171可以访问这个管理页面

3 ： nsq使用的是pub/sub模式 (发布/订阅，生产者/消费者)。我们可以先发布一个主题到nsq,然后所有订阅的服务器就会异步的从这里读取主题的内容

    Topic(左上角)：发布的主题名字

    NSQd Host：Nsq主机服务地址

    Channel：消息通道

    Depth：消息积压量

    In-flight：已经投递但是还未消费掉的消息

    Deferred：没有消费掉的延时消息

    Messages：服务器启动之后，总共接收到的消息量

    Connections：通道里面客户端的订阅数

    TimeOut：超时时间内没有被响应的消息数

    Memory + Disk：储存在内存和硬盘中总共的消息数


4: 在代码中发布主题内容，然后通过订阅Topic去异步读取消息
    go get github.com/nsqio/go-nsq


5: 测试代码

nsq是一个基于Go语言的分布式实时消息平台，它基于MIT开源协议发布，代码托管在GitHub，其当前最新版本是0.3.1版。NSQ可用于大规模系统中的实时消息服务，并且每天能够处理数亿级别的消息，其设计目标是为在分布式环境下运行的去中心化服务提供一个强大的基础架构。NSQ具有分布式、去中心化的拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。NSQ非常容易配置和部署，且具有最大的灵活性，支持众多消息协议。另外，官方还提供了拆箱即用Go和Python库。如果读者兴趣构建自己的客户端的话，还可以参考官方提供的协议规范。

NSQ是由四个重要组件构成： nsqd：一个负责接收、排队、转发消息到客户端的守护进程。 nsqlookupd：管理拓扑信息，并提供最终一致性的发现服务的守护进程。 nsqadmin：一套Web用户界面，可实时查看集群的统计数据和执行各种各样的管理任务。 utilities：常见基础功能、数据流处理工具，如nsq_stat、nsq_tail、nsq_to_file、nsq_to_http、nsq_to_nsq、to_nsq。

NSQ的主要特点如下: 具有分布式且无单点故障的拓扑结构，支持水平扩展，在无中断情况下能够无缝地添加集群节点 低延迟的消息推送，参见官方提供的性能说明文档 具有组合式的负载均衡和多播形式的消息路由 既擅长处理面向流（高吞吐量）的工作负载，也擅长处理面向Job的（低吞吐量）工作负载 消息数据既可以存储于内存中，也可以存储在磁盘中 实现了生产者、消费者自动发现和消费者自动连接生产者，参见nsqlookupd 支持安全传输层协议（TLS），从而确保了消息传递的安全性 具有与数据格式无关的消息结构，支持JSON、Protocol Buffers、MsgPacek等消息格式 非常易于部署（几乎没有依赖）和配置（所有参数都可以通过命令行进行配置） 使用了简单的TCP协议，且具有多种语言的客户端功能库 具有用于信息统计、管理员操作和实现生产者等的HTTP接口 为实时检测集成了统计数据收集器StatsD 具有强大的集群管理界面，参见nsqadmin

为了达到高效的分布式消息服务，NSQ实现了合理、智能的权衡，从而使得其能够完全适用于生产环境中，具体内容如下： 支持消息内存队列的大小设置，默认完全持久化（值为0），消息既可以可持久到磁盘，也可以保存在内存中 保证消息至少传递一次，以确保消息可以最终成功发送 收到的消息是无序的， 实现了松散订购 发现服务nsqlookupd具有最终一致性，消费者最终能够找到所有Topic生产者

官方和第三方还为NSQ开发了众多客户端功能库，如官方提供的基于HTTP的nsqd、Go客户端go-nsq、Python客户端pynsq、基于Node.js的JavaScript客户端nsqjs、异步C客户端libnsq、Java客户端nsq-java以及基于各种语言的众多第三方客户端功能库。更多客户端功能库,请读者点击这里查看。

从NSQ的设计文档中得知，单个nsqd被设计为一次能够处理多个流数据，NSQ中的数据流模型是由stream和consumer组成。Topic是一种独特的stream，Channel是一个订阅了给定Topic的consumer逻辑分组。NSQ的数据流模型结构如下图所示：

分布式的实时消息平台NSQ

从上图可以看出，单个nsqd可以有多个Topic，每个Topic又可以有多个Channel。Channel能够接收Topic所有消息的副本，从而实现了多播分发；而Channel上的每个消息被分发给它的一个订阅者，从而实现负载均衡。所有这些东西，就组成了一个可以表示各种简单和复杂拓扑结构的强大框架。

NSQ最初为提供短链接服务的应用Bitly而开发。另外，还有众多著名的应用在使用NSQ，如社交新闻网站Digg、私密的社交应用Path、著名的开源的应用容器引擎Docker、支付公司Stripe、新闻聚合网站Buzzfeed、查看家人所在位置的移动应用Life360、网络工具公司SimpleReach等。
